<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Uugen__Uuseg_gen (uugen.Uugen__Uuseg_gen)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">uugen</a> &#x00BB; Uugen__Uuseg_gen</nav><h1>Module <code>Uugen__Uuseg_gen</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span><span>[ <span>`LastUchar of Stdlib.Uchar.t</span> <span><span>| `Uchar</span> of Stdlib.Uchar.t</span> ]</span> Gen.t</span></code></dt><dd><p>The type for segmented generators. These generators produce <code>`Uchar c</code> if <code>c</code> is not at the end of a segment or produce <code>`LastUchar c</code> if <code>c</code> is the last character of a segment.</p></dd></dl><dl><dt class="spec value" id="val-of_chars"><a href="#val-of_chars" class="anchor"></a><code><span class="keyword">val</span> of_chars : <span>boundary:<span>[&lt; Uuseg.boundary ]</span></span> <span>&#45;&gt;</span> <span>chars:<span>Stdlib.Uchar.t Gen.t</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_chars ~boundary ~chars</code> segments ~chars by ~boundary.</p></dd></dl><dl><dt class="spec value" id="val-of_decoder_exn"><a href="#val-of_decoder_exn" class="anchor"></a><code><span class="keyword">val</span> of_decoder_exn : <span>boundary:<span>[&lt; Uuseg.boundary ]</span></span> <span>&#45;&gt;</span> <span>decoder:Uutf.decoder</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_decoder_exn ~boundary ~chars</code> segments ~chars by ~boundary. It uses <code>Uutf_gen.raw_of_decoder</code> internally, so calling the resulting generator can throw exceptions of the form <code>Uutf_gen.Malformed</code> or <code>Uutf_gen.Await</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_decoder_replacing"><a href="#val-of_decoder_replacing" class="anchor"></a><code><span class="keyword">val</span> of_decoder_replacing : <span>boundary:<span>[&lt; Uuseg.boundary ]</span></span> <span>&#45;&gt;</span> <span>decoder:Uutf.decoder</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_decoder_replacing ~boundary ~chars</code> segments ~chars by ~boundary, replacing malformed sequences of bytes with the unicode replacement character. It uses <code>Uutf_gen.replacing_of_decoder</code> internally, so calling the resulting generator can throw exceptions of the form <code>Uutf_gen.Await</code>.</p></dd></dl></div></body></html>